// RGB
//
// The most basic color representation.  R, G, and B are expressed on
// a scale from 0-32768 inclusive.  This is not the neopixel's
// native representation, so this class contains methods to convert
// to neopixel format.
// 

struct RGB {
    fixed R;
    fixed G;
    fixed B;

    RGB() : R(0), G(0), B(0) { }
        
    RGB(fixed r, fixed g, fixed b)
        : R(r), G(g), B(b) {
    }
    

    // scale
    //
    // Scale the color by the specified amount.  This effectively darkens it.

    RGB scale(fixed f) const {
        return RGB(fixed_mul(R, f), fixed_mul(G, f), fixed_mul(B, f));
    }
    
    // desaturation
    //
    // Desaturate the color by the specified amount (eg, interpolate to white)
    RGB desaturate(fixed f) const {
        return lerp(RGB(FIXMAX, FIXMAX, FIXMAX), f);
    }

    // lerp
    //
    // Linearly interpolate this color with another color.
    
    RGB lerp(const RGB &other, fixed offset) const {
        return RGB(
            fixed_lerp_fast(R, other.R, offset),
            fixed_lerp_fast(G, other.G, offset),
            fixed_lerp_fast(B, other.B, offset));
    }
    
    RGB sub(const RGB &other) const {
        return RGB(
            max(0, int(R) - int(other.R)),
            max(0, int(G) - int(other.G)),
            max(0, int(B) - int(other.B))
        );
    }
    
    RGB add(const RGB &other) const {
        return RGB(
            min(FIXMAX, int(R) + int(other.R)),
            min(FIXMAX, int(G) + int(other.G)),
            min(FIXMAX, int(B) + int(other.B))
        );
    }
    
    RGB maxv(const RGB &other) const {
        return RGB(
            max(R, other.R),
            max(G, other.G),
            max(B, other.B)
        );
    }
    
    // brighten
    //
    // Make the input color as bright as possible while still preserving the
    // relative proportions of R,G,B.  Therefore, hue and saturation are also
    // preserved.
    
    RGB brighten() const {
        uint16_t max = R;
        if (G > max) max = G;
        if (B > max) max = B;
        return RGB(R * FIXMAX / max, G * FIXMAX / max, B * FIXMAX / max);
    }

    // neocolor_unsafe
    //
    // Convert this color to neopixel representation.  No effort is made
    // to limit the brightness.

    uint32_t neocolor_unsafe() const {
        uint16_t r = (uint32_t(R) * (FIXMAX - 1)) >> (15 + 7);
        uint16_t g = (uint32_t(G) * (FIXMAX - 1)) >> (15 + 7);
        uint16_t b = (uint32_t(B) * (FIXMAX - 1)) >> (15 + 7);
        return (r << 16) | (g << 8) | b;
    }

    // neocolor_safe
    //
    // Convert this color to neopixel representation.  If the input color is
    // more than 1/3 brightness, it is darkened by just exactly enough to make
    // it 1/3 brightness.  This makes the color power-safe.
    
    uint32_t neocolor_safe() const {
        uint32_t total = uint32_t(R) + uint32_t(G) + uint32_t(B);
        if (total > FIXMAX) {
            uint16_t r = (uint32_t(R) * (FIXMAX - 1) / total) >> 7;
            uint16_t g = (uint32_t(G) * (FIXMAX - 1) / total) >> 7;
            uint16_t b = (uint32_t(B) * (FIXMAX - 1) / total) >> 7;
            return (r << 16) | (g << 8) | b;
        } else {
            return neocolor_unsafe();
        }
    }
};

// hue_sat
//
// Converts hue and saturation to RGB.  Saturation is expressed on a scale
// from 0-32768 inclusive, it is clamped at 32768.  Hue is expressed on a
// scale from 0-32767, it wraps at 32768.
//
// Every color generated by hue_sat has the same brightness:
// R+G+B = FIXMAX.  In other words, all colors returned
// are 1/3 brightness.  This is true even if you desaturate all the way down to
// white, it will be 1/3 brightness white.  Therefore, hue_sat returns
// colors that are power-safe.    If you want colors brighter than 1/3,
// you can call 'RGB::brighten' on the output of this function.
//
// This function works by linearly interpolating between
// keyframes.  The hue_sat_table contains the keyframes.  Initially, I used
// the six obvious keyframes - red, yellow, green, cyan, blue, magenta. 
// This was mathematically correct, but it yielded rainbow displays that
// didn't quite have enough red or yellow.  I also found that I could
// barely tell cyan apart from blue.  So I altered the array of keyframes
// slightly to emphasize red and yellow, and to make cyan a little more
// distinct.  As a result, the color wheel is just a tiny bit wrong: if
// you check the RGB values numerically, you'll see that the values at
// six points on the hexagon aren't exactly red, yellow, green, cyan, blue,
// and magenta -- but they're quite close.  You'll also see that colors which
// are supposedly complementary aren't exactly complements.  But it's so close
// that you can't tell that it's wrong with the naked eye.  Meanwhile, the
// tweaks really do make rainbows look nicer.
//

// RGB hue_sat_table[] = {
//     {32768, 0, 0},
//         {(32768+32768+30208) / 3, (0 + 0 + 2560) / 3, 0},
//     {30208, 2560, 0},
//     {26624, 6144, 0},
//     {22016, 10752, 0},
//         {(16384+16384+22016) / 3, (10752+16384+16384) / 3, 0},
//     {16384, 16384, 0},
//         {(16384+16384+10752) / 3, (22016+16384+16384) / 3, 0},
//     {10752, 22016, 0},
//     {6144, 26624, 0},
//     {2560, 30208, 0},
//     {0, 32768, 0},
//     {0, 30208, 2560},
//     {0, 26624, 6144},
//     {0, 22016, 10752},
//         {0, (22016+16384)/2, (10752+16384)/2 },
//     {0, 16384, 16384},
//     {0, 10752, 22016},
// //    {0, 6144, 26624},
//         { 0, (6144+2560)/2, (26624+30208)/2 },
// //    {0, 2560, 30208},
//     {0, 0, 32768},
//     {2560, 0, 30208},
//     {6144, 0, 26624},
//     {10752, 0, 22016},
//     {16384, 0, 16384},
//     {22016, 0, 10752},
//     {26624, 0, 6144},
//     {30208, 0, 2560},
//         {(32768+32768+30208)/3, 0, (0+0+2560)/3},
//     {32768, 0, 0},
// };

RGB hue_sat_table[] = {
    { 32768, 0, 0 },
    { 20000, 20000, 0 },
    { 0, 32768, 0 },
    { 0, 20000, 20000 },
    { 0, 0, 32768 },
    { 20000, 0, 20000 },
    { 32768, 0, 0 },
};

const int HUE_SAT_ENTRIES = (sizeof(hue_sat_table) / sizeof(RGB)) - 1;

struct RGB hue_sat(fixed hue, fixed sat) {
    sat = fixed_clamp(sat);
    uint32_t hx = (hue & 0x7FFF) * HUE_SAT_ENTRIES;
    uint32_t sector = hx >> 15;
    uint32_t offset = hx & 32767;
    RGB rgb1 = hue_sat_table[sector+0];
    RGB rgb2 = hue_sat_table[sector+1];
    RGB calculated_hue = rgb1.lerp(rgb2, offset);
    uint32_t grey33 = (32768 - sat) * (FIXMAX / 3);
    uint32_t r = (calculated_hue.R * sat + grey33) >> 15;
    uint32_t g = (calculated_hue.G * sat + grey33) >> 15;
    uint32_t b = (calculated_hue.B * sat + grey33) >> 15;
    return RGB(r, g, b);
}

const fixed HUE_RED = (FIXMAX * 0 / 12);
const fixed HUE_ORANGE = (FIXMAX * 1 / 12);
const fixed HUE_YELLOW = (FIXMAX * 2 / 12);
const fixed HUE_GREEN = (FIXMAX * 4 / 12);
const fixed HUE_CYAN = (FIXMAX * 6 / 12);
const fixed HUE_BLUE = (FIXMAX * 8 / 12);
const fixed HUE_MAGENTA = (FIXMAX * 10 / 12);
const fixed HUE_PINK = (FIXMAX * 11 / 12);

// Class Rainbow
//
// A way to represent a "rainbow" - a sequence of colors or color
// gradients.  Here is an example that looks like the flag of France:
//
//   (Red to Red), (White to White), (Blue to Blue)
//
// This rainbow consists of three easily distinguished stripes,
// the first solid red, the second solid white, the third
// solid blue.  Compare that to this rainbow specification:
//
//   (Red to White), (White to Blue)
//
// This one contains two stripes.  The first stripe is a gradual color
// blend from red to white, the second stripe is a gradual color blend
// from white to blue.  The dividing line between the two stripes
// won't be visually obvious, because the color of the right edge of
// the first stripe is equal to the color of the left edge of the
// second stripe.
//
// Normally, the stripes of a rainbow are all equally sized.   However,
// you can opt to specify an "expand=N" value.  The stripe will be N times
// as wide as a normal stripe.  Doing this uses up N slots in the
// rainbow's data table.
// 
// There is a rainbow constructor that provides a little language to
// generate a rainbow quickly.  There is also a rainbow constructor
// that accepts an index into a library of standard rainbows.
//

#define RAINBOW_MAXRANGES 256


class Rainbow {
private:
    RGB range_lo_[RAINBOW_MAXRANGES];
    RGB range_hi_[RAINBOW_MAXRANGES];
    uint32_t nranges_;
        
public:
    // clear
    //
    // Remove all stripes from the rainbow.
    
    void clear() {
        nranges_ = 0;
    }
    
    // add_range
    //
    // Add a stripe to the rainbow.
    
    void add_range(int expand, const RGB &rgb1, const RGB &rgb2) {
        for (int i = 0; i < expand; i++) {
            if (nranges_ == RAINBOW_MAXRANGES) {
                Serial.printf("Palette overflow.\n");
                return;
            }
            fixed offset1 = (FIXMAX * (i + 0)) / expand;
            fixed offset2 = (FIXMAX * (i + 1)) / expand;
            range_lo_[nranges_] = rgb1.lerp(rgb2, offset1);
            range_hi_[nranges_] = rgb1.lerp(rgb2, offset2);
            nranges_++;
        }
    }
    
        
    // apply_scale
    //
    // darken all the colors in the rainbow.
    
    void apply_scale(fixed n) {
        for (int i = 0; i < nranges_; i++) {
            range_lo_[i] = range_lo_[i].scale(n);
            range_hi_[i] = range_hi_[i].scale(n);
        }
    }
    
    // get
    //
    // obtain the color at the specified offset, where h=0
    // represents the leftmost edge of the rainbow, and h=32768
    // represents the rightmost edge.
    
    RGB get(fixed h) {
        uint32_t hx = (h & 0x7FFF) * nranges_;
        uint32_t sector = hx >> 15;
        uint32_t offset = hx & 32767;
        RGB rgb1 = range_lo_[sector];
        RGB rgb2 = range_hi_[sector];
        return rgb1.lerp(rgb2, offset);
    }
    
    // parse
    //
    // parse a little language to initialize a rainbow.  The language
    // consists of pairs of colors, where each color is represented by
    // a single letter, like this:
    //
    //  "R O, O Y, Y G, G B"
    //
    // The colors understood are: R-Red, G-Green, B-Blue, C-Cyan,
    // Y-Yellow, M-Magenta, P-Pink, O-Orange, I-Indigo, W-White,
    // H-Half-Grey, Q-Quarter-Grey, Z-Black.   The string above therefore
    // represents a four-stripe rainbow that goes red->orange,
    // orange->yellow, yellow->green, green->blue.
    //
    // Be careful, there are some intuitively obvious colors that
    // are wrong - B isn't black, G isn't grey.
    //
    // Be careful, all of them are intuitive except black. 
    //
    // Prefix modifiers can be specified before specifying a color.
    // These are:
    //
    //    "D" (dark): value = value * 7/8.
    //    "d" (very dark): value = value * 1/2.
    //    "L" (light): saturation = saturation * 7/8.
    //    "l" (very light): saturation = saturation * 1/2.
    //    "1", "2", "3"...: Set the expand level.
    //
    // So for example, "purple" isn't one of the established colors.
    // But we can put the "D" modifier in front of "P" (pink) to
    // turn it into purple.  The following is a rainbow that
    // transitions from Blue->Purple->Red:
    //
    //  "B DP, DP R"
    //
    // You can use multiple modifiers, or repeat modifiers - for
    // example, "DDP" is a darker purple.  Commas can optionally
    // be placed between pairs.  Whitespace is allowed but ignored.
    
    void parse(const char * config) {
        RGB color[2];
        int ncolors = 0;
        fixed hue = 65535;
        fixed saturation = FIXMAX;
        fixed value = FIXMAX;
        int expand = 1;
        bool check_blank = false;
        clear();
        while (true) {
            Serial.printf("Parsing %c (%d)\n", *config, *config);
            switch (*config) {
            case 0  : check_blank = true;
            case ',': check_blank = true;
            case ' ': break;
            case '1': expand = 1; break;
            case '2': expand = 2; break;
            case '3': expand = 3; break;
            case '4': expand = 4; break;
            case '5': expand = 5; break;
            case '6': expand = 6; break;
            case '7': expand = 7; break;
            case '8': expand = 8; break;
            case '9': expand = 9; break;
            case 'D': value = muldiv(value, 7, 8); break;
            case 'd': value = muldiv(value, 1, 2); break;
            case 'L': saturation = muldiv(saturation, 7, 8); break;
            case 'l': saturation = muldiv(saturation, 1, 2); break;
            case 'R': hue = HUE_RED; break;
            case 'G': hue = HUE_GREEN; break;
            case 'B': hue = HUE_BLUE; break;
            case 'C': hue = HUE_CYAN; break;
            case 'Y': hue = HUE_YELLOW; break;
            case 'M': hue = HUE_MAGENTA; break;
            case 'O': hue = HUE_ORANGE; break;
            case 'P': hue = HUE_PINK; break;
            case 'I': hue = HUE_MAGENTA; value = muldiv(value, 5, 6); break;
            case 'W': hue = 0; saturation = 0; break;
            case 'H': hue = 0; saturation = 0; value = muldiv(value, 7, 8); break;
            case 'Q': hue = 0; saturation = 0; value = muldiv(value, 1, 2); break;
            case 'Z': hue = 0; value = 0; break;
            default:
                Serial.printf("Invalid character in rainbow spec.\n");
            }
            if (hue != 65535) {
                RGB c = hue_sat(hue, saturation).scale(value);
                color[ncolors++] = c;
                Serial.printf("Stored RGB %d, %d, %d\n", c.R, c.G, c.B);
                if (ncolors == 2) {
                    add_range(expand, color[0], color[1]);
                    Serial.printf("Added range %d,%d,%d - %d,%d,%d\n",
                        color[0].R, color[0].G, color[0].B,
                        color[1].R, color[1].G, color[1].B);
                    ncolors = 0;
                    expand = 1;
                }
                hue = 65535;
                saturation = FIXMAX;
                value = FIXMAX;
            }
            if (check_blank) {
                if ((ncolors != 0) || (expand != 1) || (saturation != FIXMAX) || (value != FIXMAX) || (hue != 65535)) {
                    Serial.printf("Comma not at end of rule.\n");
                }
            }
            if (*config == 0) break;
            config++;
        }
    }

    // constructor
    //
    // This constructor uses the parse routine (above) to build
    // a rainbow from a string.
    
    Rainbow(const char *config) {
        parse(config);
    }
    
    Rainbow() {
        clear();
    }
};
